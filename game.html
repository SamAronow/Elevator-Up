<!DOCTYPE html>
<html>
<head>
  <title>Elevator Up</title>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script src="database.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .section { margin-bottom: 20px; }
    .cards { font-size: 24px; }
    .card-button {
      margin: 5px;
      padding: 10px;
      font-size: 20px;
      cursor: pointer;
    }
  
    .card-button:disabled {
      cursor: not-allowed;
      background-color: #ccc;
    }
  </style>
  
  <script>

    /*get data about game
    ---------------------------------------------------------------------------------------
    */
    var turn=1
    var player = getPlayerFromURL();
    var code = getCodeFromURL();
    var numPlayers
    var playerName
    var players

    if (player==1){
        var opponent=2
    }
    else{
        var opponent=1
    }

    function getPlayerFromURL() {
      var params = new URLSearchParams(window.location.search);
      return params.get("player"); // "player1" or "player2"
    }

    function getCodeFromURL() {
      var params = new URLSearchParams(window.location.search);
      return params.get("room"); // "player1" or "player2"
    }

    /*Set up card helper stuff
    ---------------------------------------------------------------------------------------
    */

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function deal(deck,count) {
      return deck.splice(0,count);
    }
    
    const cardRank = {
        "2": 1,
        "3": 2,
        "4": 3,
        "5": 4,
        "6": 5,
        "7": 6,
        "8": 7,
        "9": 8,
        "10": 9,
        "L": 10,
        "S": 11,
        "D": 12,
        "N": 13,
        "P": 14
    };

    function sortCards(cards) {
        return cards.slice().sort((a, b) => cardRank[a] - cardRank[b]);
    }

    function legalMove(move,lastVal){
        //move: 2-10
        //last: L,P,null
        const numMove = parseInt(move);
        const numLast = parseInt(lastVal);


        // Check if both are numbers from 2 to 10
        if (!isNaN(numMove)) {
            if(!isNaN(numLast)){
                return numMove >= numLast;
            }
            return lastVal=='L' || lastVal==null            
        }
        else{
            return true
        }


        return false; // Default to false for now
    }

    /* Set up functionality for flashing tab title
    ---------------------------------------------------------------------------------------
    */

    let flashInterval;
    let flashing = false;

    function startFlashingTitle(message) {
        if (flashing) return; // prevent multiple intervals
        flashing = true;

        let showingMessage = false;
        flashInterval = setInterval(() => {
            document.title = showingMessage ? "Pay Attention" : message;
            showingMessage = !showingMessage;
        }, 1000); // toggle every second
    }

    function stopFlashingTitle() {
        clearInterval(flashInterval);
        var isMyTurn = turn === Number(player);
        document.title = isMyTurn ? "Your turn" : "Opponent Turn"
        flashing = false;
    }

    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Tab became active
            stopFlashingTitle();
        }
    });

    /* Set up function to getCards for the end at the start of the game
    ---------------------------------------------------------------------------------------
    */

    function getEnd() {
        return new Promise(async (resolve) => {
            const hand = await read(`/${code}/hands/${player}`);
            let selected = [];

            const popup = document.createElement("div");
            popup.id = "popup";
            popup.style.position = "fixed";
            popup.style.top = "0";
            popup.style.left = "0";
            popup.style.width = "100vw";
            popup.style.height = "100vh";
            popup.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
            popup.style.display = "flex";
            popup.style.flexDirection = "column";
            popup.style.alignItems = "center";
            popup.style.justifyContent = "center";
            popup.style.zIndex = "1000";

            popup.innerHTML = `
                <div style="background:white; padding:20px; border-radius:10px; text-align:center;">
                    <h3>Select 2 cards for your Ends</h3>
                    <div id="card-selection" style="margin: 10px;">
                        ${hand.map((card, i) => 
                            `<button data-index="${i}" class="end-select">${card}</button>`).join(" ")}
                    </div>
                    <button id="confirmEnds" disabled>Confirm</button>
                    <div id="waitMessage" style="margin-top: 10px;"></div>
                </div>
            `;
            document.body.appendChild(popup);

            const buttons = popup.querySelectorAll(".end-select");
            const confirmBtn = popup.querySelector("#confirmEnds");
            const waitMessage = popup.querySelector("#waitMessage");

            buttons.forEach(btn => {
                btn.onclick = () => {
                    const index = Number(btn.dataset.index);
                    if (selected.includes(index)) {
                        selected = selected.filter(i => i !== index);
                        btn.style.backgroundColor = "";
                    } else if (selected.length < 2) {
                        selected.push(index);
                        btn.style.backgroundColor = "lightgreen";
                    }

                    confirmBtn.disabled = selected.length !== 2;
                };
            });

            confirmBtn.onclick = async () => {
                const ends = [hand[selected[0]], hand[selected[1]]];
                const newHand = hand.filter((_, i) => !selected.includes(i));

                await write(`/${code}/hands/${player}`, newHand);
                await write(`/${code}/ends/${player}`, ends);

                waitMessage.textContent = "Waiting for all players to choose...";

                // Start polling until all players have submitted 2 ends
                const endsRef = database.ref(`/${code}/ends`);
                endsRef.on('value', (snapshot) => {
                    const endsData = snapshot.val() || {};
                    let allDone = true;

                    for (let i = 1; i <= numPlayers; i++) {
                        if (!Array.isArray(endsData[i]) || endsData[i].length !== 2) {
                            allDone = false;
                            break;
                        }
                    }

                    if (allDone) {
                        popup.remove();
                        endsRef.off(); // stop listening
                        resolve();
                    }
                });
            };
        });
    }


    /* Set up functionality for winner pop up and play again and delete room options
    ---------------------------------------------------------------------------------------
    */
    let play_again = false;
    let delete_game = false;
     let playAgainBtn, deleteBtn;
    let otherPlayerChoices = {}; // e.g., {1: {playAgain: true, deleteGame: false}, ...}

    async function winner(win) {
        const message = win == player ? "You won!" : "Opponent won!";

        const winpopup = document.createElement("div");
        Object.assign(winpopup.style, {
            position: "fixed", top: "0", left: "0",
            width: "100vw", height: "100vh",
            backgroundColor: "rgba(0, 0, 0, 0.7)",
            display: "flex", flexDirection: "column",
            justifyContent: "center", alignItems: "center",
            zIndex: "10000"
        });

        const winMessageBox = document.createElement("div");
        Object.assign(winMessageBox.style, {
            background: "#fff", padding: "30px",
            borderRadius: "10px", fontSize: "24px",
            textAlign: "center", display: "flex",
            flexDirection: "column", alignItems: "center"
        });

        const messageText = document.createElement("div");
        messageText.textContent = message;

        const buttonContainer = document.createElement("div");
        Object.assign(buttonContainer.style, {
            display: "flex", flexDirection: "column",
            marginTop: "20px", gap: "10px"
        });

        playAgainBtn = document.createElement("button");
        playAgainBtn.textContent = "Play Again";
        Object.assign(playAgainBtn.style, {
            padding: "10px 20px", fontSize: "18px",
            backgroundColor: "#eee", transition: "background-color 0.3s"
        });
        playAgainBtn.onclick = () => chooseOption("playAgain");

        deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Delete Room";
        Object.assign(deleteBtn.style, {
            padding: "10px 20px", fontSize: "18px",
            backgroundColor: "#eee", transition: "background-color 0.3s"
        });
        deleteBtn.onclick = () => chooseOption("deleteGame");

        const statusMessage = document.createElement("div");
        Object.assign(statusMessage.style, {
            marginTop: "15px", fontSize: "18px", color: "#333"
        });

        buttonContainer.appendChild(playAgainBtn);
        buttonContainer.appendChild(deleteBtn);
        winMessageBox.appendChild(messageText);
        winMessageBox.appendChild(buttonContainer);
        winMessageBox.appendChild(statusMessage);
        winpopup.appendChild(winMessageBox);
        document.body.appendChild(winpopup);

        // Attach listeners to all players
        for (let i = 1; i <= numPlayers; i++) {
            if (i == player) continue;

            firebase.database().ref(`/${code}/players/${i}`).on('value', snapshot => {
                otherPlayerChoices[i] = snapshot.val() || {};
                updateStatus();
            });
        }

        // Listen for your own data to refresh button highlights
        firebase.database().ref(`/${code}/players/${player}`).on('value', snapshot => {
            const data = snapshot.val() || {};
            play_again = !!data.playAgain;
            delete_game = !!data.deleteGame;
            highlightChoice();
            updateStatus();
        });


        function updateStatus() {
            const allPlayAgain = play_again && Object.values(otherPlayerChoices).every(p => p.playAgain);
            const allDelete = delete_game && Object.values(otherPlayerChoices).every(p => p.deleteGame);

            if (allPlayAgain) {
                playAgain();
            } else if (allDelete) {
                deleteGame();
            } else {
                const playAgainNames = Object.values(otherPlayerChoices)
                    .filter(p => p.playAgain)
                    .map(p => p.Name);

                const deleteNames = Object.values(otherPlayerChoices)
                    .filter(p => p.deleteGame)
                    .map(p => p.Name);

                const playNameText = playAgainNames.join(", ");
                const deleteNameText = deleteNames.join(", ");

                if (playAgainNames.length > 0 && deleteNames.length > 0) {
                    statusMessage.innerHTML = `
                        ${playNameText} ${playAgainNames.length === 1 ? "wants" : "want"} to play again<br>
                        ${deleteNameText} ${deleteNames.length === 1 ? "wants" : "want"} to delete room
                    `;
                }
                else if (playAgainNames.length > 0) {
                    statusMessage.textContent = `${playNameText} ${playAgainNames.length === 1 ? "wants" : "want"} to play again`;
                } 
                else if (deleteNames.length > 0){
                    statusMessage.textContent = `${deleteNameText} ${deleteNames.length === 1 ? "wants" : "want"} to delete room`;
                }
                else {
                    statusMessage.textContent = "Waiting on others...";
                }
            }
        }

        function highlightChoice() {
            playAgainBtn.style.backgroundColor = play_again ? "#cce5cc" : "#eee";
            deleteBtn.style.backgroundColor = delete_game ? "#f5cccc" : "#eee";
        }
    }

    async function chooseOption(option) {
        if (option === "playAgain") {
            play_again = true;
            delete_game = false;
            playAgainBtn.style.backgroundColor = "#cce5cc";
            deleteBtn.style.backgroundColor = "#eee";
            await update(`/${code}/players/${player}`, {
                playAgain: true,
                deleteGame: false
            });

        } 
        else if (option === "deleteGame") {
            delete_game = true;
            play_again = false;
            deleteBtn.style.backgroundColor = "#f5cccc";
            playAgainBtn.style.backgroundColor = "#eee";
            await update(`/${code}/players/${player}`, {
                playAgain: false,
                deleteGame: true
            });
        }
    }


    async function playAgain(){
        if (player==1){

            const removePlayerPaths = [];
            for (let i = 1; i <= numPlayers; i++) {
                removePlayerPaths.push(removeNode(`/${code}/players/${i}/deleteGame`));
                removePlayerPaths.push(removeNode(`/${code}/players/${i}/playAgain`));
            }
            
            await Promise.all([
                removeNode(`/${code}/hands`),
                removeNode(`/${code}/inPlay`),
                removeNode(`/${code}/lastAmt`),
                removeNode(`/${code}/lastMove`),
                removeNode(`/${code}/lastVal`),
                removeNode(`/${code}/mysteryPlayed`),
                removeNode(`/${code}/mysts`),
                removeNode(`/${code}/turn`),
                removeNode(`/${code}/deck`),
                removeNode(`/${code}/ends`),
                ...removePlayerPaths,
                write(`/${code}/gameStarted`, false),
                write(`/${code}/initialized`, false),
                write(`/${code}/resetDone`, true)
            ]);
            location.reload();
        }
        else {
            firebase.database().ref(`/${code}/resetDone`).on('value', snapshot => {
                if (snapshot.val() === true) {
                    location.reload();
                }
            });
        }
    }

    async function deleteGame(){
        if (player==1){
            await removeNode(`/${code}`)
        }
        window.location.href = 'index.html';
    }


    /* Set up the initialization process
    ---------------------------------------------------------------------------------------
    */

    window.onload = initializeGame;

    var initRef = database.ref(`/${code}/initialized`);
    initRef.on('value', async (snapshot) => {
        var inval = snapshot.val();
        if (inval === true) {
            console.log("Game initialized — starting game");
            initializeGame();
        }  
    });

    async function initializeGame() {
        players = await read(`/${code}/players`);
        playerName= players[player]?.Name
        const gameStarted = await read(`/${code}/gameStarted`);
        numPlayers = await read(`/${code}/playerCount`);

        // Ensure all players are marked as "Used"
        const allPlayersJoined = players && players.every(p => p && p.Used);
        if (!allPlayersJoined) {
            console.log("Waiting for all players to join...");
            return;
        }

        const alreadyInit = await read(`/${code}/initialized`);
        if (alreadyInit === true) {
            if (!gameStarted) {
                write(`/${code}/players/${player}/playAgain`, false);
                write(`/${code}/players/${player}/deleteGame`, false);
                await getEnd();
            }

            // Listen for turn changes
            const turnRef = database.ref(`/${code}/turn`);
            turnRef.on('value', () => updateGame());

            // Listen for mystery plays
            const mystRef = database.ref(`/${code}/mysteryPlayed`);
            mystRef.on('value', async (snapshot) => {
                let turn = await read(`/${code}/turn`);
                let lastVal = await read(`/${code}/lastVal`);
                var isMyTurn = turn === Number(player);

                let data = snapshot.val();
                if (!data || !data.played) return;

                let card = data.played;
                let isLegal = legalMove(card, lastVal);

                const oldPopup = document.getElementById("popup");
                if (oldPopup) oldPopup.remove();

                const popup = document.createElement("div");
                popup.id = "popup";
                popup.style = `
                    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
                    background-color: rgba(0, 0, 0, 0.5); display: flex;
                    justify-content: center; align-items: center; z-index: 1000;
                `;

                const messageBox = document.createElement("div");
                messageBox.style = "background:#fff; padding:30px; border-radius:8px; text-align:center; font-size:20px";
                
                players = await read(`/${code}/players`);
                const currentPlayerName = players[turn]?.Name || `Player ${turn}`;
                const displayName = isMyTurn ? "Your" : `${currentPlayerName}'s`;
                messageBox.innerHTML = `
                    ${displayName} card played was <strong>${card}</strong><br>
                    It is <strong style="color:${isLegal ? 'green' : 'red'}">${isLegal ? 'legal' : 'not legal'}</strong>
                `;


                popup.appendChild(messageBox);
                document.body.appendChild(popup);

                setTimeout(() => {
                    if (isMyTurn) {
                        const actionContainer = document.createElement("div");
                        actionContainer.style.marginTop = "20px";
                        if (isLegal) {
                            const playBtn = document.createElement("button");
                            playBtn.textContent = "Play Card";
                            playBtn.onclick = () => {
                                popup.remove();
                                endTurn(card, 1, 2);
                            };
                            actionContainer.appendChild(playBtn);
                        } else {
                            const takeBtn = document.createElement("button");
                            takeBtn.textContent = "Take Cards";
                            takeBtn.onclick = () => {
                                popup.remove();
                                takeCards(card);
                            };
                            actionContainer.appendChild(takeBtn);
                        }
                        messageBox.appendChild(actionContainer);
                    } else {
                        messageBox.innerHTML += `<br><br>Waiting for opponent to ${isLegal ? "play" : "take cards"}.`;
                    }
                }, 1200);
            });

            await write(`/${code}/gameStarted`, true);
            //updateGame();
            return;
        }

        // --- Game not yet initialized, so initialize it now ---
        const baseDeck = ["D", "P"];
        for (let i = 0; i < 4; i++) {
            for (let j = 2; j <= 10; j++) baseDeck.push(j.toString());
            baseDeck.push("L", "N", "S");
        }
        shuffle(baseDeck);

        const deck = [...baseDeck];
        const hands = {};
        const mysts = {};
        const ends = {};

        for (let i = 1; i <= numPlayers; i++) {
            hands[i] = deal(deck, 5);
            mysts[i] = deal(deck, 3);
            ends[i] = [];
        }

        const writes = [
            write(`/${code}/deck`, deck),
            write(`/${code}/inPlay`, []),
            write(`/${code}/turn`, 1),
            write(`/${code}/mysteryPlayed`, false),
            write(`/${code}/lastMove`, null),
            write(`/${code}/lastVal`, null),
            write(`/${code}/lastAmt`, null),
            write(`/${code}/resetDone`, false),
        ];

        for (let i = 1; i <= numPlayers; i++) {
            writes.push(write(`/${code}/hands/${i}`, hands[i]));
            writes.push(write(`/${code}/mysts/${i}`, mysts[i]));
            writes.push(write(`/${code}/ends/${i}`, []));
        }

        await Promise.all(writes);

        await write(`/${code}/initialized`, true)
    }


   /* Set up the end of turn processes
    ---------------------------------------------------------------------------------------
    */

    async function processClick(card,stage) {
        if (stage==2){
            await write(`/${code}/mysteryPlayed`, {
                played: card,
                date: Date.now()  // or some turn counter
            });
            return
        }
        let count=0
        if (stage==0){
            count = Array.from(document.querySelectorAll("#hand .card-button"))
                   .filter(btn => btn.dataset.card === card).length;
        }
        if (stage==1){
            count = Array.from(document.querySelectorAll(".end-card"))
                   .filter(btn => btn.dataset.card === card).length;
        }
        if (count === 1 || card=='L' || card=='S' || card=='N') {
            endTurn(card, 1,stage);
            return;
        }

        // Create overlay
        const overlay = document.createElement("div");
        overlay.className = "popup-overlay";
        overlay.style.position = "fixed";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100%";
        overlay.style.height = "100%";
        overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        overlay.style.zIndex = "9998";

        // Create popup box
        const popup = document.createElement("div");
        popup.className = "popup";
        popup.style.position = "fixed";
        popup.style.top = "50%";
        popup.style.left = "50%";
        popup.style.transform = "translate(-50%, -50%)";
        popup.style.background = "white";
        popup.style.padding = "20px";
        popup.style.border = "2px solid black";
        popup.style.zIndex = "9999";
        popup.innerHTML = `<h3>Select how many '${card}' to play:</h3>`;

        for (let i = 1; i <= count; i++) {
            const btn = document.createElement("button");
            btn.textContent = i;
            btn.onclick = () => {
            document.body.removeChild(overlay);
            document.body.removeChild(popup);
            endTurn(card, i,stage);
            };
            popup.appendChild(btn);
        }


        document.body.appendChild(overlay);
        document.body.appendChild(popup);
    }

    async function endTurn(card,amt,stage) {   
        var [deck,hand,end_cards,myst_cards,lastMove,inPlay,prevAmt] = await Promise.all([
                read(`/${code}/deck`),
                read(`/${code}/hands/${player}`),
                read(`/${code}/ends/${player}`),
                read(`/${code}/mysts/${player}`),
                read(`/${code}/lastMove`),
                read(`/${code}/inPlay`),
                read(`/${code}/lastAmt`),
        ]);


        if (card == 'N') {
            write(`/${code}/lastMove`, 'N');
            write(`/${code}/lastVal`, null);
            write(`/${code}/lastAmt`, 1);
        } 
        else if (!isNaN(parseInt(card)) && (amt == 4 || ((amt + prevAmt) % 4 == 0 && card == lastMove))) {
            write(`/${code}/lastMove`, 'New from 4 of ' + card);
            write(`/${code}/lastVal`, null);
            write(`/${code}/lastAmt`, 4);
        } 
        else if (card == 'D' || card == 'S') {
            write(`/${code}/lastMove`, card);
            if (card == lastMove) {
                write(`/${code}/lastAmt`, amt + prevAmt);
            } else {
                write(`/${code}/lastAmt`, amt);
            }
        } 
        else {
            write(`/${code}/lastMove`, card);
            write(`/${code}/lastVal`, card);
            if (card == lastMove) {
                write(`/${code}/lastAmt`, amt + prevAmt);
            } else {
                write(`/${code}/lastAmt`, amt);
            }
        }

        if (stage==0){
            if (inPlay === null) {
                inPlay = [];
            }
            if (deck === null) {
                deck = [];
            }
            if (hand === null) {
                hand = [];
            }
            for (i=0; i<amt; i++){
                inPlay.push(card)
                const index = hand.indexOf(card);
                hand.splice(hand.indexOf(card), 1);
                if (deck.length!=0 && hand.length<=2){
                    hand.push(deal(deck,1)[0])
                }
            }
            await write(`/${code}/hands/${player}`, hand)
            await write(`/${code}/deck`, deck)
        }
        if (stage==1){
            if (inPlay === null) {
                inPlay = [];
            }
            if (end_cards === null) {
                end_cards = [];
            }
            for (i=0; i<amt; i++){
                inPlay.push(card)
                const index = end_cards.indexOf(card);
                end_cards.splice(end_cards.indexOf(card), 1);
            }
            await write(`/${code}/ends/${player}`, end_cards)
        }
        if (stage==2){
            if (inPlay === null) {
                inPlay = [];
            }
            if (myst_cards === null) {
                myst_cards = [];
            }
            inPlay.push(card)
            const index = myst_cards.indexOf(card);
            myst_cards.splice(myst_cards.indexOf(card), 1);
            await write(`/${code}/mysts/${player}`, myst_cards)
        }
    
        if (card =='N' || (!isNaN(parseInt(card)) && (amt==4 || ((amt+prevAmt)%4==0 && card==lastMove)))){
            write(`/${code}/inPlay`,[])
        }
        else{
            write(`/${code}/inPlay`,inPlay)
        }

        let newTurn = (turn % numPlayers) + 1;
        temp=turn
        write(`/${code}/turn`,newTurn)
        if (card =='N' || (!isNaN(parseInt(card)) && (amt==4 || ((amt+prevAmt)%4==0 && card==lastMove)))){
            write(`/${code}/turn`,temp)   
        }
        else if (card =='D'){
            newTurn = (newTurn % numPlayers) + 1;
            write(`/${code}/turn`,newTurn)   
        }
    }  


    async function takeCards(card){
        var [hand,inPlay,myst_cards] = await Promise.all([
                read(`/${code}/hands/${player}`),
                read(`/${code}/inPlay`),
                read(`/${code}/mysts/${player}`)
            ]);
        if (inPlay === null) {
            inPlay = [];
        }
        if (hand === null) {
            hand = [];
        }
        if (card!=null) {
            if (myst_cards === null) {
                myst_cards = [];
            }
            inPlay.push(card)
            const index = myst_cards.indexOf(card);
            myst_cards.splice(myst_cards.indexOf(card), 1);
            await write(`/${code}/mysts/${player}`, myst_cards)
        }
        hand.push(...inPlay);
        inPlay=[]

        let newTurn = (turn % numPlayers) + 1;
        await Promise.all([
            write(`/${code}/lastMove`, null),
            write(`/${code}/lastVal`, null),
            write(`/${code}/lastAmt`, null),
            write(`/${code}/inPlay`, inPlay),
            write(`/${code}/hands/${player}`, hand),
            write(`/${code}/turn`, newTurn)
        ]);

    }

    /* Set up the Displays
    ---------------------------------------------------------------------------------------
    */

   async function updateGame() {
    var [deck, inPlay, hand, ends, mysts, lastMove, lastVal, lastAmt, allPlayers] = await Promise.all([
        read(`/${code}/deck`),
        read(`/${code}/inPlay`),
        read(`/${code}/hands/${player}`),
        read(`/${code}/ends/${player}`),
        read(`/${code}/mysts/${player}`),
        read(`/${code}/lastMove`),
        read(`/${code}/lastVal`),
        read(`/${code}/lastAmt`),
        read(`/${code}/players`)
    ]);

    if (inPlay === null) inPlay = [];
    if (deck === null)  deck = [];
    if (hand === null) hand = [];
    if (ends === null) ends = [];
    if (mysts === null) mysts = []

    turn = await read(`/${code}/turn`);

    const opponents = allPlayers
        .map((p, idx) => ({ ...p, id: idx }))
        .filter((p, idx) => p && idx !== Number(player) && idx !== 0);


    const opponentHTML = await Promise.all(opponents.map(async (p) => {
    var [h, e, m] = await Promise.all([
        read(`/${code}/hands/${p.id}`),
        read(`/${code}/ends/${p.id}`),
        read(`/${code}/mysts/${p.id}`)
    ]);
    if (h === null) h = [];
    if (e === null) e = [];
    if (m === null) m = [];

    // Bold and dot if it's their turn
    const isTurn = turn === p.id;
    const nameDisplay = isTurn
        ? `<b style="color:green;">${p.Name}</b>`
        : `${p.Name}`;

    return `
        <div class="opponent-block">
            <h3>${nameDisplay}</h3>
            <div>Hand: ${"X ".repeat(h.length).trim()}</div>
            <div>Ends: ${e.join(" ")}</div>
            <div>Mystery: ${"X ".repeat(m.length).trim()}</div>
        </div>
        `;
    }));


    const deck_len = deck.length;
    const play_len = inPlay.length;
    const sortedHand = sortCards(hand);
    const isMyTurn = turn === Number(player);

    const youNameDisplay = isMyTurn
        ? `<b style="color:green;">You</b>`
        : `You`;

    document.title = isMyTurn ? "Your turn" : "Opponent Turn";
    if (document.visibilityState !== 'visible') startFlashingTitle("Your Turn!");

    let lastMoveText = "Last played: None";
    if (lastMove != null) {
        const extra = (lastMove === "D" || lastMove === "S") ? ` (on ${lastVal})` : "";
        lastMoveText = `Last played: ${lastMove}${extra}`;
    }


    document.body.innerHTML = `
        <div class="section" style="display:flex; gap: 40px; overflow-x: auto;">
            ${opponentHTML.join("")}
        </div>

        <hr>

        <div class="section">
            <pre>Cards in Deck: ${deck_len}</pre>
            <pre>Cards in Play: ${play_len}</pre>
            <h3>Last played:</h3>
            <pre>${lastMoveText}</pre>
            <pre>Quantity: ${lastAmt}</pre>
        </div>

        <div class="section">
            <h2>${youNameDisplay}</h2>
            <div class="cards" id="hand">
                ${sortedHand.map(card => 
                    `<button class="card-button" data-card="${card}">${card}</button>`
                ).join(" ")}
            </div>

            <div class="cards" id="ends">
                <p>Ends </p>
                ${(ends).map(card =>
                    `<button class="card-button end-card" data-card="${card}">${card}</button>`
                ).join(" ")}
            </div>

            <div class="cards" id="ends">
            <p>Mystery </p>
            ${(mysts).map(card =>
                `<button class="card-button myst-card" data-card="${card}">X</button>`
            ).join(" ")}
        </div>
    </div>

    <div class="section">
        <h3 id="turn-status">${isMyTurn ? "Your turn" : "Waiting for opponent..."}</h3>
    </div>
`;


    canPlay = updateHandButtons(isMyTurn, lastVal, deck, hand, ends);

    // Check for win condition
    if ((hand?.length ?? 0) === 0 && (ends?.length ?? 0) === 0 && (mysts?.length ?? 0) === 0) {
        winner(player);
    }

    for (let p of opponents) {
        var [h, e, m] = await Promise.all([
            read(`/${code}/hands/${p.id}`),
            read(`/${code}/ends/${p.id}`),
            read(`/${code}/mysts/${p.id}`)
        ]);

        if ((h?.length ?? 0) === 0 && (e?.length ?? 0) === 0 && (m?.length ?? 0) === 0) {
            winner(p.id);
        }
    }
}


    function updateHandButtons(enabled, lastVal,deck,hand,ends) {
        let canPlay = false;

        const handButtons = document.querySelectorAll("#hand .card-button");
        const endCards = document.querySelectorAll(".end-card");
        const mystCards = document.querySelectorAll(".myst-card");

        if (hand.length != 0){
            handButtons.forEach(btn => {
                const card = btn.dataset.card;
                const isLegal = legalMove(card, lastVal);
                if (enabled && isLegal) {
                    canPlay = true;
                }
                btn.disabled = !(enabled && isLegal);
                btn.style.backgroundColor = enabled ? "#fff" : "#ccc";
                btn.onclick = (enabled && isLegal) ? () => processClick(card,0) : null;
            });
            endCards.forEach(btn => {
                btn.disabled = true;
                btn.style.backgroundColor = "#ccc";
                btn.onclick = null;
            });
            mystCards.forEach(btn => {
                btn.disabled = true;
                btn.style.backgroundColor = "#ccc";
                btn.onclick = null;
            });
        }
        else if (ends.length!=0){
            endCards.forEach(btn => {
                let card = btn.dataset.card;
                let isLegal = legalMove(card, lastVal);
                if (enabled && isLegal) {
                    canPlay = true;
                }
                btn.disabled = !(enabled && isLegal);
                btn.style.backgroundColor = enabled ? "#fff" : "#ccc";
                btn.onclick = (enabled && isLegal) ? () => processClick(card,1) : null;
            });
            mystCards.forEach(btn => {
                btn.disabled = true;
                btn.style.backgroundColor = "#ccc";
                btn.onclick = null;
            });
        }
        else{
            mystCards.forEach(btn => {
                card = btn.dataset.card;
                canPlay = true;
                btn.disabled = !(enabled);
                btn.style.backgroundColor = enabled ? "#fff" : "#ccc";
                btn.onclick = enabled ? () => processClick(card,2) : null;
            });
        }

        // Only append "Take Cards" button if no moves are possible
        if (enabled && !canPlay) {
            const takeBtn = document.createElement("button");
            takeBtn.id = "take-cards-btn";
            takeBtn.textContent = "Take Cards";
            takeBtn.onclick = () => takeCards(null);


            const handSection = document.getElementById("hand");
            handSection.appendChild(takeBtn);
        }

        return canPlay;
    }
  </script>
</head>
<body>
  <h1>Game Setup In Progress...</h1>
</body>
</html>